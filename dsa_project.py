# -*- coding: utf-8 -*-
"""DSA Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y7ypL_JgKF9tZ0TCoPr1yBuyA55t6C3P
"""

"""
Complete Python Trading Simulator with Angel One API Integration
Features:
- Angel One SmartAPI integration
- Yahoo Finance fallback (FREE)
- Moving Average Crossover Strategy
- DSA implementations (Sliding Window, Priority Queue, etc.)
- Backtesting engine
- Live trading signals
- Beautiful Streamlit UI

Installation:
pip install streamlit pandas numpy yfinance requests pyotp plotly

Run:
streamlit run trading_simulator.py
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import requests
import pyotp
import json
from datetime import datetime, timedelta
from collections import deque
import heapq
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# ============================================================================
# ANGEL ONE API CLIENT
# ============================================================================

class AngelOneClient:
    """Angel One SmartAPI Client for Indian Stock Market"""

    def __init__(self, api_key=None, client_code=None, password=None, totp_secret=None):
        self.base_url = "https://apiconnect.angelbroking.com"
        self.api_key = api_key
        self.client_code = client_code
        self.password = password
        self.totp_secret = totp_secret
        self.jwt_token = None
        self.refresh_token = None
        self.feed_token = None

    def generate_totp(self):
        """Generate TOTP for 2FA authentication"""
        if not self.totp_secret:
            return "000000"  # Dummy for testing
        totp = pyotp.TOTP(self.totp_secret)
        return totp.now()

    def login(self):
        """Authenticate with Angel One and get JWT token"""
        url = f"{self.base_url}/rest/auth/angelbroking/user/v1/loginByPassword"

        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-UserType': 'USER',
            'X-SourceID': 'WEB',
            'X-ClientLocalIP': '127.0.0.1',
            'X-ClientPublicIP': '127.0.0.1',
            'X-MACAddress': '00:00:00:00:00:00',
            'X-PrivateKey': self.api_key
        }

        payload = {
            'clientcode': self.client_code,
            'password': self.password,
            'totp': self.generate_totp()
        }

        try:
            response = requests.post(url, headers=headers, json=payload)
            data = response.json()

            if data.get('status'):
                self.jwt_token = data['data']['jwtToken']
                self.refresh_token = data['data']['refreshToken']
                self.feed_token = data['data'].get('feedToken', '')
                return True, "Login successful"
            else:
                return False, data.get('message', 'Login failed')
        except Exception as e:
            return False, f"Error: {str(e)}"

    def get_quote(self, symbol_token, exchange='NSE'):
        """Get live quote for a stock"""
        url = f"{self.base_url}/rest/secure/angelbroking/market/v1/quote/"

        headers = {
            'Authorization': f'Bearer {self.jwt_token}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-UserType': 'USER',
            'X-SourceID': 'WEB',
            'X-ClientLocalIP': '127.0.0.1',
            'X-ClientPublicIP': '127.0.0.1',
            'X-MACAddress': '00:00:00:00:00:00',
            'X-PrivateKey': self.api_key
        }

        payload = {
            'mode': 'FULL',
            'exchangeTokens': {
                exchange: [symbol_token]
            }
        }

        try:
            response = requests.post(url, headers=headers, json=payload)
            data = response.json()

            if data.get('status'):
                return data['data']['fetched'][0]
            return None
        except Exception as e:
            st.error(f"Error fetching quote: {e}")
            return None

    def get_historical_data(self, symbol_token, exchange='NSE', interval='ONE_DAY',
                          from_date=None, to_date=None):
        """Get historical candlestick data"""
        url = f"{self.base_url}/rest/secure/angelbroking/historical/v1/getCandleData"

        if not from_date:
            from_date = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d 09:15')
        if not to_date:
            to_date = datetime.now().strftime('%Y-%m-%d 15:30')

        headers = {
            'Authorization': f'Bearer {self.jwt_token}',
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-UserType': 'USER',
            'X-SourceID': 'WEB',
            'X-ClientLocalIP': '127.0.0.1',
            'X-ClientPublicIP': '127.0.0.1',
            'X-MACAddress': '00:00:00:00:00:00',
            'X-PrivateKey': self.api_key
        }

        payload = {
            'exchange': exchange,
            'symboltoken': symbol_token,
            'interval': interval,
            'fromdate': from_date,
            'todate': to_date
        }

        try:
            response = requests.post(url, headers=headers, json=payload)
            data = response.json()

            if data.get('status') and data.get('data'):
                # Convert to DataFrame
                df = pd.DataFrame(data['data'],
                                columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                return df
            return None
        except Exception as e:
            st.error(f"Error fetching historical data: {e}")
            return None

# ============================================================================
# YAHOO FINANCE CLIENT (FREE ALTERNATIVE)
# ============================================================================

class YahooFinanceClient:
    """Yahoo Finance client for free stock data"""

    # NSE stock symbols for Yahoo Finance
    STOCK_SYMBOLS = {
        'RELIANCE': 'RELIANCE.NS',
        'TCS': 'TCS.NS',
        'HDFCBANK': 'HDFCBANK.NS',
        'INFY': 'INFY.NS',
        'ICICIBANK': 'ICICIBANK.NS',
        'HINDUNILVR': 'HINDUNILVR.NS',
        'ITC': 'ITC.NS',
        'SBIN': 'SBIN.NS',
        'BHARTIARTL': 'BHARTIARTL.NS',
        'KOTAKBANK': 'KOTAKBANK.NS',
        'LT': 'LT.NS',
        'WIPRO': 'WIPRO.NS',
        'AXISBANK': 'AXISBANK.NS',
        'MARUTI': 'MARUTI.NS',
        'TITAN': 'TITAN.NS'
    }

    @staticmethod
    def get_historical_data(symbol, period='6mo'):
        """Get historical data from Yahoo Finance"""
        try:
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period)
            df.reset_index(inplace=True)
            df.columns = [col.lower() for col in df.columns]
            return df
        except Exception as e:
            st.error(f"Error fetching Yahoo Finance data: {e}")
            return None

    @staticmethod
    def get_current_price(symbol):
        """Get current price"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period='1d')
            if not data.empty:
                return data['Close'].iloc[-1]
            return None
        except:
            return None

# ============================================================================
# DSA IMPLEMENTATIONS
# ============================================================================

class SlidingWindow:
    """
    DSA: Sliding Window for efficient Moving Average calculation
    Time Complexity: O(1) per element (vs O(n) naive approach)
    """
    def __init__(self, window_size):
        self.window = deque(maxlen=window_size)
        self.sum = 0.0
        self.window_size = window_size

    def add(self, value):
        """Add new value and calculate MA in O(1)"""
        if len(self.window) == self.window_size:
            # Remove oldest value from sum
            self.sum -= self.window[0]

        self.window.append(value)
        self.sum += value

        return self.sum / len(self.window)

    def get_ma(self):
        """Get current moving average"""
        return self.sum / len(self.window) if self.window else 0

class OrderBook:
    """
    DSA: Priority Queue (Heap) for Order Book
    Buy orders: Max heap (highest price first)
    Sell orders: Min heap (lowest price first)
    """
    def __init__(self):
        self.buy_orders = []   # Max heap
        self.sell_orders = []  # Min heap

    def add_buy_order(self, price, quantity, timestamp):
        """Add buy order (max heap - negate price)"""
        heapq.heappush(self.buy_orders, (-price, timestamp, quantity))

    def add_sell_order(self, price, quantity, timestamp):
        """Add sell order (min heap)"""
        heapq.heappush(self.sell_orders, (price, timestamp, quantity))

    def get_best_buy(self):
        """Get highest buy price"""
        if self.buy_orders:
            return -self.buy_orders[0][0]
        return None

    def get_best_sell(self):
        """Get lowest sell price"""
        if self.sell_orders:
            return self.sell_orders[0][0]
        return None

    def match_orders(self):
        """Try to match buy and sell orders"""
        if not self.buy_orders or not self.sell_orders:
            return None

        best_buy = -self.buy_orders[0][0]
        best_sell = self.sell_orders[0][0]

        if best_buy >= best_sell:
            # Match!
            buy_order = heapq.heappop(self.buy_orders)
            sell_order = heapq.heappop(self.sell_orders)

            return {
                'price': best_sell,
                'quantity': min(buy_order[2], sell_order[2]),
                'buy_price': best_buy,
                'sell_price': best_sell
            }
        return None

# ============================================================================
# TRADING STRATEGIES
# ============================================================================

class MovingAverageCrossover:
    """
    Moving Average Crossover Strategy
    Buy: When short MA crosses above long MA (Golden Cross)
    Sell: When short MA crosses below long MA (Death Cross)
    """
    def __init__(self, short_window=5, long_window=20):
        self.short_window = short_window
        self.long_window = long_window

    def calculate_ma(self, prices, window):
        """Calculate moving average using Sliding Window (O(n))"""
        ma = []
        sw = SlidingWindow(window)

        for price in prices:
            ma_value = sw.add(price)
            ma.append(ma_value if len(sw.window) == window else None)

        return ma

    def generate_signals(self, df):
        """Generate buy/sell signals"""
        # Calculate MAs
        df['ma_short'] = self.calculate_ma(df['close'].values, self.short_window)
        df['ma_long'] = self.calculate_ma(df['close'].values, self.long_window)

        # Generate signals
        df['signal'] = 'HOLD'

        for i in range(1, len(df)):
            if df['ma_short'].iloc[i-1] is not None and df['ma_long'].iloc[i-1] is not None:
                # Golden Cross - BUY
                if (df['ma_short'].iloc[i-1] <= df['ma_long'].iloc[i-1] and
                    df['ma_short'].iloc[i] > df['ma_long'].iloc[i]):
                    df.at[i, 'signal'] = 'BUY'
                    df.at[i, 'reason'] = f'Golden Cross: {self.short_window}-MA crossed above {self.long_window}-MA'

                # Death Cross - SELL
                elif (df['ma_short'].iloc[i-1] >= df['ma_long'].iloc[i-1] and
                      df['ma_short'].iloc[i] < df['ma_long'].iloc[i]):
                    df.at[i, 'signal'] = 'SELL'
                    df.at[i, 'reason'] = f'Death Cross: {self.short_window}-MA crossed below {self.long_window}-MA'

        return df

class RSIStrategy:
    """
    RSI (Relative Strength Index) Strategy
    Buy: RSI < 30 (oversold)
    Sell: RSI > 70 (overbought)
    """
    def __init__(self, period=14, oversold=30, overbought=70):
        self.period = period
        self.oversold = oversold
        self.overbought = overbought

    def calculate_rsi(self, prices):
        """Calculate RSI indicator"""
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gains = []
        avg_losses = []

        # Initial averages
        avg_gain = np.mean(gains[:self.period])
        avg_loss = np.mean(losses[:self.period])

        avg_gains.append(avg_gain)
        avg_losses.append(avg_loss)

        # Calculate RSI
        for i in range(self.period, len(gains)):
            avg_gain = (avg_gain * (self.period - 1) + gains[i]) / self.period
            avg_loss = (avg_loss * (self.period - 1) + losses[i]) / self.period

            avg_gains.append(avg_gain)
            avg_losses.append(avg_loss)

        rsi = []
        for avg_gain, avg_loss in zip(avg_gains, avg_losses):
            if avg_loss == 0:
                rsi.append(100)
            else:
                rs = avg_gain / avg_loss
                rsi.append(100 - (100 / (1 + rs)))

        # Pad with None for initial period
        return [None] * self.period + rsi

    def generate_signals(self, df):
        """Generate buy/sell signals based on RSI"""
        df['rsi'] = self.calculate_rsi(df['close'].values)
        df['signal'] = 'HOLD'

        for i in range(1, len(df)):
            if df['rsi'].iloc[i] is not None:
                # Oversold - BUY
                if df['rsi'].iloc[i] < self.oversold and df['rsi'].iloc[i-1] >= self.oversold:
                    df.at[i, 'signal'] = 'BUY'
                    df.at[i, 'reason'] = f'RSI oversold: {df["rsi"].iloc[i]:.1f} < {self.oversold}'

                # Overbought - SELL
                elif df['rsi'].iloc[i] > self.overbought and df['rsi'].iloc[i-1] <= self.overbought:
                    df.at[i, 'signal'] = 'SELL'
                    df.at[i, 'reason'] = f'RSI overbought: {df["rsi"].iloc[i]:.1f} > {self.overbought}'

        return df

# ============================================================================
# BACKTESTING ENGINE
# ============================================================================

class BacktestEngine:
    """Backtesting engine to test strategies on historical data"""

    def __init__(self, initial_capital=100000, brokerage_pct=0.0003):
        self.initial_capital = initial_capital
        self.brokerage_pct = brokerage_pct

    def run_backtest(self, df):
        """Run backtest on dataframe with signals"""
        cash = self.initial_capital
        shares = 0
        trades = []
        portfolio_values = []

        for idx, row in df.iterrows():
            current_price = row['close']
            signal = row['signal']

            # Execute BUY signal
            if signal == 'BUY' and cash >= current_price:
                shares_to_buy = int(cash / current_price)
                cost = shares_to_buy * current_price
                brokerage = cost * self.brokerage_pct
                total_cost = cost + brokerage

                if total_cost <= cash:
                    cash -= total_cost
                    shares += shares_to_buy

                    trades.append({
                        'date': row['date'] if 'date' in row else idx,
                        'type': 'BUY',
                        'price': current_price,
                        'shares': shares_to_buy,
                        'cost': total_cost,
                        'brokerage': brokerage,
                        'reason': row.get('reason', 'Buy signal')
                    })

            # Execute SELL signal
            elif signal == 'SELL' and shares > 0:
                revenue = shares * current_price
                brokerage = revenue * self.brokerage_pct
                net_revenue = revenue - brokerage

                cash += net_revenue

                trades.append({
                    'date': row['date'] if 'date' in row else idx,
                    'type': 'SELL',
                    'price': current_price,
                    'shares': shares,
                    'revenue': net_revenue,
                    'brokerage': brokerage,
                    'reason': row.get('reason', 'Sell signal')
                })

                shares = 0

            # Calculate portfolio value
            portfolio_value = cash + (shares * current_price)
            portfolio_values.append(portfolio_value)

        # Final portfolio value
        final_value = cash + (shares * df['close'].iloc[-1])
        profit = final_value - self.initial_capital
        profit_pct = (profit / self.initial_capital) * 100

        # Calculate metrics
        max_drawdown = self.calculate_max_drawdown(portfolio_values)
        win_rate = self.calculate_win_rate(trades)

        # Buy and hold comparison
        buy_hold_shares = int(self.initial_capital / df['close'].iloc[0])
        buy_hold_value = buy_hold_shares * df['close'].iloc[-1]
        buy_hold_profit = buy_hold_value - self.initial_capital
        buy_hold_pct = (buy_hold_profit / self.initial_capital) * 100

        return {
            'trades': trades,
            'portfolio_values': portfolio_values,
            'final_value': final_value,
            'profit': profit,
            'profit_pct': profit_pct,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'num_trades': len(trades),
            'buy_hold_value': buy_hold_value,
            'buy_hold_profit': buy_hold_profit,
            'buy_hold_pct': buy_hold_pct
        }

    def calculate_max_drawdown(self, portfolio_values):
        """Calculate maximum drawdown"""
        peak = portfolio_values[0]
        max_dd = 0

        for value in portfolio_values:
            if value > peak:
                peak = value
            dd = ((peak - value) / peak) * 100
            if dd > max_dd:
                max_dd = dd

        return max_dd

    def calculate_win_rate(self, trades):
        """Calculate win rate"""
        if len(trades) < 2:
            return 0

        wins = 0
        total_pairs = 0

        for i in range(0, len(trades) - 1, 2):
            if trades[i]['type'] == 'BUY' and i + 1 < len(trades) and trades[i + 1]['type'] == 'SELL':
                total_pairs += 1
                if trades[i + 1]['price'] > trades[i]['price']:
                    wins += 1

        return (wins / total_pairs * 100) if total_pairs > 0 else 0

# ============================================================================
# STREAMLIT UI
# ============================================================================

def main():
    st.set_page_config(page_title="Python Trading Simulator", page_icon="üìà", layout="wide")

    # Header
    st.title("üêç Python Trading Simulator with Angel One API")
    st.markdown("**Complete backtesting & live trading system for Indian stock market**")

    # Sidebar
    st.sidebar.header("‚öôÔ∏è Configuration")

    # Data source selection
    data_source = st.sidebar.selectbox(
        "Data Source",
        ["Yahoo Finance (FREE)", "Angel One API (Requires credentials)"]
    )

    # Stock selection
    if data_source == "Yahoo Finance (FREE)":
        stock_options = list(YahooFinanceClient.STOCK_SYMBOLS.keys())
        selected_stock = st.sidebar.selectbox("Select Stock", stock_options)
        symbol = YahooFinanceClient.STOCK_SYMBOLS[selected_stock]
    else:
        selected_stock = st.sidebar.text_input("Stock Symbol", "RELIANCE-EQ")
        symbol_token = st.sidebar.text_input("Symbol Token", "2885")

    # Strategy selection
    strategy_type = st.sidebar.selectbox(
        "Trading Strategy",
        ["Moving Average Crossover", "RSI Strategy"]
    )

    # Strategy parameters
    if strategy_type == "Moving Average Crossover":
        short_ma = st.sidebar.slider("Short MA Period", 3, 20, 5)
        long_ma = st.sidebar.slider("Long MA Period", 10, 50, 20)
    else:
        rsi_period = st.sidebar.slider("RSI Period", 7, 21, 14)
        oversold = st.sidebar.slider("Oversold Level", 20, 40, 30)
        overbought = st.sidebar.slider("Overbought Level", 60, 80, 70)

    # Capital
    initial_capital = st.sidebar.number_input(
        "Initial Capital (‚Çπ)",
        min_value=10000,
        max_value=10000000,
        value=100000,
        step=10000
    )

    # Time period
    period = st.sidebar.selectbox(
        "Time Period",
        ["1mo", "3mo", "6mo", "1y", "2y"]
    )

    # Angel One credentials (if selected)
    if data_source == "Angel One API (Requires credentials)":
        with st.sidebar.expander("üîê Angel One Credentials"):
            api_key = st.text_input("API Key", type="password")
            client_code = st.text_input("Client Code")
            password = st.text_input("Password", type="password")
            totp_secret = st.text_input("TOTP Secret", type="password")

    # Run backtest button
    run_backtest = st.sidebar.button("üöÄ Run Backtest", type="primary")

    # Main content
    if run_backtest:
        with st.spinner("Fetching data and running backtest..."):
            # Fetch data
            if data_source == "Yahoo Finance (FREE)":
                df = YahooFinanceClient.get_historical_data(symbol, period)
            else:
                # Angel One API
                client = AngelOneClient(api_key, client_code, password, totp_secret)
                success, message = client.login()

                if success:
                    st.success(f"‚úÖ {message}")
                    df = client.get_historical_data(symbol_token)
                else:
                    st.error(f"‚ùå {message}")
                    st.info("üí° Using Yahoo Finance as fallback")
                    df = YahooFinanceClient.get_historical_data(symbol, period)

            if df is not None and not df.empty:
                # Apply strategy
                if strategy_type == "Moving Average Crossover":
                    strategy = MovingAverageCrossover(short_ma, long_ma)
                else:
                    strategy = RSIStrategy(rsi_period, oversold, overbought)

                df = strategy.generate_signals(df)

                # Run backtest
                engine = BacktestEngine(initial_capital)
                results = engine.run_backtest(df)

                # Display results
                st.success("‚úÖ Backtest Complete!")

                # Metrics
                col1, col2, col3, col4 = st.columns(4)

                with col1:
                    st.metric(
                        "Strategy Return",
                        f"‚Çπ{results['profit']:,.0f}",
                        f"{results['profit_pct']:.2f}%"
                    )

                with col2:
                    st.metric(
                        "Buy & Hold Return",
                        f"‚Çπ{results['buy_hold_profit']:,.0f}",
                        f"{results['buy_hold_pct']:.2f}%"
                    )

                with col3:
                    st.metric(
                        "Win Rate",
                        f"{results['win_rate']:.1f}%",
                        f"{results['num_trades']} trades"
                    )

                with col4:
                    st.metric(
                        "Max Drawdown",
                        f"{results['max_drawdown']:.2f}%"
                    )

                # Price chart
                st.subheader("üìä Price & Indicators")

                fig = make_subplots(
                    rows=2, cols=1,
                    shared_xaxes=True,
                    vertical_spacing=0.03,
                    row_heights=[0.7, 0.3]
                )

                # Price and MAs
                fig.add_trace(
                    go.Scatter(x=df.index, y=df['close'], name='Price', line=dict(color='blue')),
                    row=1, col=1
                )

                if 'ma_short' in df.columns:
                    fig.add_trace(
                        go.Scatter(x=df.index, y=df['ma_short'], name=f'MA {short_ma}',
                                 line=dict(color='orange', dash='dash')),
                        row=1, col=1
                    )
                    fig.add_trace(
                        go.Scatter(x=df.index, y=df['ma_long'], name=f'MA {long_ma}',
                                 line=dict(color='red', dash='dash')),
                        row=1, col=1
                    )

                # Buy/Sell signals
                buy_signals = df[df['signal'] == 'BUY']
                sell_signals = df[df['signal'] == 'SELL']

                fig.add_trace(
                    go.Scatter(x=buy_signals.index, y=buy_signals['close'],
                             mode='markers', name='Buy', marker=dict(color='green', size=10, symbol='triangle-up')),
                    row=1, col=1
                )

                fig.add_trace(
                    go.Scatter(x=sell_signals.index, y=sell_signals['close'],
                             mode='markers', name='Sell', marker=dict(color='red', size=10, symbol='triangle-down')),
                    row=1, col=1
                )

                # Portfolio value
                fig.add_trace(
                    go.Scatter(x=df.index, y=results['portfolio_values'], name='Portfolio Value',
                             line=dict(color='green', width=2)),
                    row=2, col=1
                )

                fig.update_layout(height=700, showlegend=True, title_text=f"{selected_stock} Trading Analysis")
                fig.update_xaxes(title_text="Date", row=2, col=1)
                fig.update_yaxes(title_text="Price (‚Çπ)", row=1, col=1)
                fig.update_yaxes(title_text="Portfolio (‚Çπ)", row=2, col=1)

                st.plotly_chart(fig, use_container_width=True)

                # Trade history
                st.subheader("üìã Trade History")
                if results['trades']:
                    trades_df = pd.DataFrame(results['trades'])
                    st.dataframe(trades_df, use_container_width=True)
                else:
                    st.info("No trades executed during this period")
            else:
                st.error("‚ùå Failed to fetch data. Please check your inputs.")
    else:
        # Welcome screen
        st.info("üëà Configure settings in the sidebar and click 'Run Backtest' to start")

        st.markdown("### üéØ Features")
        col1, col2 = st.columns(2)

    with col1:
        st.markdown("""
    **Data Sources:**
    - ‚úÖ Yahoo Finance (Free, No signup)
    - ‚úÖ Angel One SmartAPI (Free, Requires account)

    **Strategies:**
    - ‚úÖ Moving Average Crossover
    - ‚úÖ RSI (Relative Strength Index)

    **DSA Concepts:**
    - üìä Arrays & Lists (price data, indicators)
    - üßÆ Sliding Window (moving averages, RSI)
    - üîÅ Loops & Iteration (backtesting logic)
    - üóÇ Dictionaries / Hash Maps (symbol-wise data)
    - ‚è± Time Complexity Optimization (large datasets)
    - üìà Queues / Deques (rolling calculations)
    """)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile trading_simulator.py
# 
# # PASTE THE ENTIRE TRADING SIMULATOR CODE HERE
# # (The complete code I gave you earlier)

"""
Google Colab Trading Simulator - Jupyter Native Version
No Streamlit required - runs directly in Colab!

Installation (Run in first cell):
!pip install yfinance pandas numpy matplotlib seaborn plotly requests pyotp -q

Usage:
1. Install packages
2. Run this entire script
3. Use the functions at the bottom to test strategies
"""

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import requests
import pyotp
from datetime import datetime, timedelta
from collections import deque
import heapq
import warnings
warnings.filterwarnings('ignore')

# Set style
sns.set_style('darkgrid')
plt.rcParams['figure.figsize'] = (15, 8)

print("‚úÖ All packages imported successfully!")
print("üìä Trading Simulator Ready!\n")

# ============================================================================
# DATA FETCHING
# ============================================================================

class StockDataFetcher:
    """Fetch stock data from Yahoo Finance (FREE)"""

    # NSE stocks for Yahoo Finance
    NIFTY_50 = {
        'RELIANCE': 'RELIANCE.NS',
        'TCS': 'TCS.NS',
        'HDFCBANK': 'HDFCBANK.NS',
        'INFY': 'INFY.NS',
        'ICICIBANK': 'ICICIBANK.NS',
        'HINDUNILVR': 'HINDUNILVR.NS',
        'ITC': 'ITC.NS',
        'SBIN': 'SBIN.NS',
        'BHARTIARTL': 'BHARTIARTL.NS',
        'KOTAKBANK': 'KOTAKBANK.NS',
        'LT': 'LT.NS',
        'WIPRO': 'WIPRO.NS',
        'AXISBANK': 'AXISBANK.NS',
        'MARUTI': 'MARUTI.NS',
        'TITAN': 'TITAN.NS',
        'SUNPHARMA': 'SUNPHARMA.NS',
        'ULTRACEMCO': 'ULTRACEMCO.NS',
        'ASIANPAINT': 'ASIANPAINT.NS',
        'NESTLEIND': 'NESTLEIND.NS',
        'TATAMOTORS': 'TATAMOTORS.NS'
    }

    @staticmethod
    def get_data(stock_name, period='6mo'):
        """
        Fetch historical data for a stock

        Parameters:
        - stock_name: Stock name (e.g., 'RELIANCE', 'TCS')
        - period: '1mo', '3mo', '6mo', '1y', '2y', '5y'

        Returns: DataFrame with OHLCV data
        """
        if stock_name in StockDataFetcher.NIFTY_50:
            symbol = StockDataFetcher.NIFTY_50[stock_name]
        else:
            symbol = stock_name

        print(f"üì• Fetching data for {stock_name} ({symbol})...")

        try:
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period)

            if df.empty:
                print(f"‚ùå No data found for {stock_name}")
                return None

            df.reset_index(inplace=True)
            df.columns = [col.lower() for col in df.columns]

            print(f"‚úÖ Fetched {len(df)} days of data")
            print(f"üìÖ Date range: {df['date'].min()} to {df['date'].max()}")
            print(f"üí∞ Latest price: ‚Çπ{df['close'].iloc[-1]:.2f}\n")

            return df

        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None

    @staticmethod
    def list_stocks():
        """List all available stocks"""
        print("üìã Available Nifty 50 Stocks:")
        print("=" * 50)
        for i, stock in enumerate(StockDataFetcher.NIFTY_50.keys(), 1):
            print(f"{i:2d}. {stock}")
        print("=" * 50)

# ============================================================================
# DSA: SLIDING WINDOW FOR MOVING AVERAGE
# ============================================================================

class SlidingWindow:
    """
    Efficient Moving Average using Sliding Window
    Time Complexity: O(1) per element (vs O(n) naive)
    """
    def __init__(self, window_size):
        self.window = deque(maxlen=window_size)
        self.sum = 0.0
        self.window_size = window_size

    def add(self, value):
        """Add value and get MA in O(1)"""
        if len(self.window) == self.window_size:
            self.sum -= self.window[0]

        self.window.append(value)
        self.sum += value

        return self.sum / len(self.window)

def calculate_ma_optimized(prices, window):
    """Calculate MA using Sliding Window (DSA)"""
    ma = []
    sw = SlidingWindow(window)

    for price in prices:
        ma_value = sw.add(price)
        ma.append(ma_value if len(sw.window) == window else None)

    return ma

# ============================================================================
# TRADING STRATEGIES
# ============================================================================

class TradingStrategy:
    """Base class for trading strategies"""

    @staticmethod
    def moving_average_crossover(df, short_window=5, long_window=20):
        """
        MA Crossover Strategy
        BUY: Short MA crosses above Long MA (Golden Cross)
        SELL: Short MA crosses below Long MA (Death Cross)
        """
        print(f"üìä Calculating Moving Average Crossover ({short_window}/{long_window})...")

        # Calculate MAs using optimized sliding window
        df['ma_short'] = calculate_ma_optimized(df['close'].values, short_window)
        df['ma_long'] = calculate_ma_optimized(df['close'].values, long_window)

        # Generate signals
        df['signal'] = 'HOLD'
        df['reason'] = ''

        for i in range(1, len(df)):
            if df['ma_short'].iloc[i-1] is not None and df['ma_long'].iloc[i-1] is not None:
                # Golden Cross - BUY
                if (df['ma_short'].iloc[i-1] <= df['ma_long'].iloc[i-1] and
                    df['ma_short'].iloc[i] > df['ma_long'].iloc[i]):
                    df.at[i, 'signal'] = 'BUY'
                    df.at[i, 'reason'] = f'Golden Cross: {short_window}MA > {long_window}MA'

                # Death Cross - SELL
                elif (df['ma_short'].iloc[i-1] >= df['ma_long'].iloc[i-1] and
                      df['ma_short'].iloc[i] < df['ma_long'].iloc[i]):
                    df.at[i, 'signal'] = 'SELL'
                    df.at[i, 'reason'] = f'Death Cross: {short_window}MA < {long_window}MA'

        buy_signals = len(df[df['signal'] == 'BUY'])
        sell_signals = len(df[df['signal'] == 'SELL'])
        print(f"‚úÖ Generated {buy_signals} BUY and {sell_signals} SELL signals\n")

        return df

    @staticmethod
    def rsi_strategy(df, period=14, oversold=30, overbought=70):
        """
        RSI Strategy
        BUY: RSI < 30 (oversold)
        SELL: RSI > 70 (overbought)
        """
        print(f"üìä Calculating RSI Strategy (period={period})...")

        # Calculate price changes
        deltas = df['close'].diff()
        gains = deltas.where(deltas > 0, 0)
        losses = -deltas.where(deltas < 0, 0)

        # Calculate average gains and losses
        avg_gains = gains.rolling(window=period).mean()
        avg_losses = losses.rolling(window=period).mean()

        # Calculate RS and RSI
        rs = avg_gains / avg_losses
        df['rsi'] = 100 - (100 / (1 + rs))

        # Generate signals
        df['signal'] = 'HOLD'
        df['reason'] = ''

        for i in range(1, len(df)):
            if not pd.isna(df['rsi'].iloc[i]):
                # Oversold - BUY
                if df['rsi'].iloc[i] < oversold and df['rsi'].iloc[i-1] >= oversold:
                    df.at[i, 'signal'] = 'BUY'
                    df.at[i, 'reason'] = f'RSI oversold: {df["rsi"].iloc[i]:.1f}'

                # Overbought - SELL
                elif df['rsi'].iloc[i] > overbought and df['rsi'].iloc[i-1] <= overbought:
                    df.at[i, 'signal'] = 'SELL'
                    df.at[i, 'reason'] = f'RSI overbought: {df["rsi"].iloc[i]:.1f}'

        buy_signals = len(df[df['signal'] == 'BUY'])
        sell_signals = len(df[df['signal'] == 'SELL'])
        print(f"‚úÖ Generated {buy_signals} BUY and {sell_signals} SELL signals\n")

        return df

# ============================================================================
# BACKTESTING ENGINE
# ============================================================================

class Backtester:
    """Backtest trading strategies"""

    def __init__(self, initial_capital=100000, brokerage_pct=0.0003):
        self.initial_capital = initial_capital
        self.brokerage_pct = brokerage_pct

    def run(self, df):
        """Run backtest on dataframe with signals"""
        print("üîÑ Running backtest...")

        cash = self.initial_capital
        shares = 0
        trades = []
        portfolio_values = []

        for idx, row in df.iterrows():
            current_price = row['close']
            signal = row['signal']

            # BUY signal
            if signal == 'BUY' and cash >= current_price:
                shares_to_buy = int(cash / current_price)
                cost = shares_to_buy * current_price
                brokerage = cost * self.brokerage_pct
                total_cost = cost + brokerage

                if total_cost <= cash:
                    cash -= total_cost
                    shares += shares_to_buy

                    trades.append({
                        'date': row['date'],
                        'type': 'BUY',
                        'price': current_price,
                        'shares': shares_to_buy,
                        'cost': total_cost,
                        'brokerage': brokerage,
                        'reason': row.get('reason', '')
                    })

            # SELL signal
            elif signal == 'SELL' and shares > 0:
                revenue = shares * current_price
                brokerage = revenue * self.brokerage_pct
                net_revenue = revenue - brokerage

                cash += net_revenue

                trades.append({
                    'date': row['date'],
                    'type': 'SELL',
                    'price': current_price,
                    'shares': shares,
                    'revenue': net_revenue,
                    'brokerage': brokerage,
                    'reason': row.get('reason', '')
                })

                shares = 0

            # Track portfolio value
            portfolio_value = cash + (shares * current_price)
            portfolio_values.append(portfolio_value)

        # Calculate final results
        final_price = df['close'].iloc[-1]
        final_value = cash + (shares * final_price)
        profit = final_value - self.initial_capital
        profit_pct = (profit / self.initial_capital) * 100

        # Buy & Hold comparison
        buy_hold_shares = int(self.initial_capital / df['close'].iloc[0])
        buy_hold_value = buy_hold_shares * final_price
        buy_hold_profit = buy_hold_value - self.initial_capital
        buy_hold_pct = (buy_hold_profit / self.initial_capital) * 100

        # Calculate metrics
        max_drawdown = self._calculate_max_drawdown(portfolio_values)
        win_rate = self._calculate_win_rate(trades)

        results = {
            'trades': trades,
            'portfolio_values': portfolio_values,
            'final_value': final_value,
            'profit': profit,
            'profit_pct': profit_pct,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'num_trades': len(trades),
            'buy_hold_value': buy_hold_value,
            'buy_hold_profit': buy_hold_profit,
            'buy_hold_pct': buy_hold_pct
        }

        print("‚úÖ Backtest complete!\n")
        self._print_results(results)

        return results

    def _calculate_max_drawdown(self, portfolio_values):
        """Calculate maximum drawdown"""
        peak = portfolio_values[0]
        max_dd = 0

        for value in portfolio_values:
            if value > peak:
                peak = value
            dd = ((peak - value) / peak) * 100
            if dd > max_dd:
                max_dd = dd

        return max_dd

    def _calculate_win_rate(self, trades):
        """Calculate win rate"""
        if len(trades) < 2:
            return 0

        wins = 0
        total_pairs = 0

        for i in range(0, len(trades) - 1, 2):
            if trades[i]['type'] == 'BUY' and i + 1 < len(trades):
                if trades[i + 1]['type'] == 'SELL':
                    total_pairs += 1
                    if trades[i + 1]['price'] > trades[i]['price']:
                        wins += 1

        return (wins / total_pairs * 100) if total_pairs > 0 else 0

    def _print_results(self, results):
        """Print backtest results"""
        print("=" * 70)
        print("üìä BACKTEST RESULTS")
        print("=" * 70)
        print(f"üí∞ Initial Capital:     ‚Çπ{self.initial_capital:,.2f}")
        print(f"üíµ Final Value:         ‚Çπ{results['final_value']:,.2f}")
        print(f"üìà Profit/Loss:         ‚Çπ{results['profit']:,.2f} ({results['profit_pct']:+.2f}%)")
        print(f"üìâ Max Drawdown:        {results['max_drawdown']:.2f}%")
        print(f"üéØ Win Rate:            {results['win_rate']:.1f}%")
        print(f"üîÑ Total Trades:        {results['num_trades']}")
        print()
        print("üîµ Buy & Hold Comparison:")
        print(f"   Final Value:         ‚Çπ{results['buy_hold_value']:,.2f}")
        print(f"   Profit/Loss:         ‚Çπ{results['buy_hold_profit']:,.2f} ({results['buy_hold_pct']:+.2f}%)")
        print()

        if results['profit_pct'] > results['buy_hold_pct']:
            print("‚úÖ Strategy OUTPERFORMED buy & hold!")
        else:
            print("‚ö†Ô∏è  Strategy UNDERPERFORMED buy & hold")
        print("=" * 70)
        print()

# ============================================================================
# VISUALIZATION
# ============================================================================

def plot_results(df, results, stock_name):
    """Plot backtest results with beautiful charts"""

    # Create figure with subplots
    fig = make_subplots(
        rows=3, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        subplot_titles=(
            f'{stock_name} - Price & Indicators',
            'Portfolio Value',
            'RSI' if 'rsi' in df.columns else 'Signals'
        ),
        row_heights=[0.5, 0.3, 0.2]
    )

    # Row 1: Price and Moving Averages
    fig.add_trace(
        go.Scatter(x=df['date'], y=df['close'], name='Price',
                  line=dict(color='#2E86AB', width=2)),
        row=1, col=1
    )

    if 'ma_short' in df.columns:
        fig.add_trace(
            go.Scatter(x=df['date'], y=df['ma_short'], name='Short MA',
                      line=dict(color='#F77F00', width=1, dash='dash')),
            row=1, col=1
        )

    if 'ma_long' in df.columns:
        fig.add_trace(
            go.Scatter(x=df['date'], y=df['ma_long'], name='Long MA',
                      line=dict(color='#D62828', width=1, dash='dash')),
            row=1, col=1
        )

    # Add buy/sell markers
    buy_signals = df[df['signal'] == 'BUY']
    sell_signals = df[df['signal'] == 'SELL']

    fig.add_trace(
        go.Scatter(x=buy_signals['date'], y=buy_signals['close'],
                  mode='markers', name='Buy Signal',
                  marker=dict(color='green', size=12, symbol='triangle-up')),
        row=1, col=1
    )

    fig.add_trace(
        go.Scatter(x=sell_signals['date'], y=sell_signals['close'],
                  mode='markers', name='Sell Signal',
                  marker=dict(color='red', size=12, symbol='triangle-down')),
        row=1, col=1
    )

    # Row 2: Portfolio Value
    fig.add_trace(
        go.Scatter(x=df['date'], y=results['portfolio_values'],
                  name='Portfolio Value', fill='tozeroy',
                  line=dict(color='#06A77D', width=2)),
        row=2, col=1
    )

    # Add starting capital line
    fig.add_hline(y=results['final_value'], line_dash="dash",
                  line_color="gray", row=2, col=1,
                  annotation_text=f"Final: ‚Çπ{results['final_value']:,.0f}")

    # Row 3: RSI or Volume
    if 'rsi' in df.columns:
        fig.add_trace(
            go.Scatter(x=df['date'], y=df['rsi'], name='RSI',
                      line=dict(color='purple', width=2)),
            row=3, col=1
        )
        fig.add_hline(y=70, line_dash="dash", line_color="red", row=3, col=1)
        fig.add_hline(y=30, line_dash="dash", line_color="green", row=3, col=1)
    else:
        fig.add_trace(
            go.Bar(x=df['date'], y=df['volume'], name='Volume',
                  marker_color='lightblue'),
            row=3, col=1
        )

    # Update layout
    fig.update_layout(
        height=900,
        showlegend=True,
        hovermode='x unified',
        template='plotly_white'
    )

    fig.update_xaxes(title_text="Date", row=3, col=1)
    fig.update_yaxes(title_text="Price (‚Çπ)", row=1, col=1)
    fig.update_yaxes(title_text="Value (‚Çπ)", row=2, col=1)
    fig.update_yaxes(title_text="RSI" if 'rsi' in df.columns else "Volume", row=3, col=1)

    fig.show()

def plot_trade_history(results):
    """Plot trade history as a table"""
    if not results['trades']:
        print("‚ùå No trades to display")
        return

    trades_df = pd.DataFrame(results['trades'])
    trades_df['date'] = pd.to_datetime(trades_df['date']).dt.strftime('%Y-%m-%d')
    trades_df['price'] = trades_df['price'].round(2)

    # Calculate P&L for each trade pair
    pnl_list = []
    for i in range(0, len(trades_df) - 1, 2):
        if i + 1 < len(trades_df):
            if trades_df.iloc[i]['type'] == 'BUY' and trades_df.iloc[i+1]['type'] == 'SELL':
                pnl = trades_df.iloc[i+1]['revenue'] - trades_df.iloc[i]['cost']
                pnl_list.extend([pnl, pnl])
            else:
                pnl_list.append(0)
        else:
            pnl_list.append(0)

    if len(pnl_list) < len(trades_df):
        pnl_list.append(0)

    trades_df['pnl'] = pnl_list

    print("\nüìã TRADE HISTORY:")
    print("=" * 100)
    print(trades_df.to_string(index=False))
    print("=" * 100)

# ============================================================================
# EASY-TO-USE FUNCTIONS
# ============================================================================

def quick_backtest(stock_name='RELIANCE', strategy='MA', period='6mo',
                   capital=100000, short_ma=5, long_ma=20):
    """
    Quick backtest with one function call

    Parameters:
    - stock_name: Stock name (e.g., 'RELIANCE', 'TCS')
    - strategy: 'MA' or 'RSI'
    - period: '1mo', '3mo', '6mo', '1y', '2y'
    - capital: Initial capital in rupees
    - short_ma: Short MA period (for MA strategy)
    - long_ma: Long MA period (for MA strategy)

    Example:
    >>> quick_backtest('RELIANCE', 'MA', '1y', 100000, 10, 50)
    """

    print("üöÄ Starting Quick Backtest...")
    print(f"üìà Stock: {stock_name}")
    print(f"üìä Strategy: {strategy}")
    print(f"üí∞ Capital: ‚Çπ{capital:,}")
    print(f"üìÖ Period: {period}\n")

    # Fetch data
    df = StockDataFetcher.get_data(stock_name, period)
    if df is None:
        return None

    # Apply strategy
    if strategy.upper() == 'MA':
        df = TradingStrategy.moving_average_crossover(df, short_ma, long_ma)
    elif strategy.upper() == 'RSI':
        df = TradingStrategy.rsi_strategy(df)
    else:
        print(f"‚ùå Unknown strategy: {strategy}")
        return None

    # Run backtest
    backtester = Backtester(capital)
    results = backtester.run(df)

    # Plot results
    plot_results(df, results, stock_name)
    plot_trade_history(results)

    return df, results

def compare_strategies(stock_name='RELIANCE', period='6mo', capital=100000):
    """
    Compare MA Crossover vs RSI strategy

    Example:
    >>> compare_strategies('TCS', '1y', 100000)
    """
    print("üîÑ Comparing Strategies...\n")

    # Fetch data
    df = StockDataFetcher.get_data(stock_name, period)
    if df is None:
        return None

    # Test MA strategy
    print("=" * 70)
    print("üìä STRATEGY 1: Moving Average Crossover")
    print("=" * 70)
    df_ma = df.copy()
    df_ma = TradingStrategy.moving_average_crossover(df_ma, 5, 20)
    backtester = Backtester(capital)
    results_ma = backtester.run(df_ma)

    # Test RSI strategy
    print("\n" + "=" * 70)
    print("üìä STRATEGY 2: RSI")
    print("=" * 70)
    df_rsi = df.copy()
    df_rsi = TradingStrategy.rsi_strategy(df_rsi)
    results_rsi = backtester.run(df_rsi)

    # Comparison
    print("\n" + "=" * 70)
    print("üèÜ STRATEGY COMPARISON")
    print("=" * 70)
    print(f"{'Metric':<25} {'MA Crossover':<20} {'RSI':<20}")
    print("-" * 70)
    print(f"{'Return':<25} {results_ma['profit_pct']:>18.2f}% {results_rsi['profit_pct']:>18.2f}%")
    print(f"{'Win Rate':<25} {results_ma['win_rate']:>18.1f}% {results_rsi['win_rate']:>18.1f}%")
    print(f"{'Max Drawdown':<25} {results_ma['max_drawdown']:>18.2f}% {results_rsi['max_drawdown']:>18.2f}%")
    print(f"{'Total Trades':<25} {results_ma['num_trades']:>20} {results_rsi['num_trades']:>20}")
    print("=" * 70)

    # Determine winner
    if results_ma['profit_pct'] > results_rsi['profit_pct']:
        print("üèÜ Winner: Moving Average Crossover!")
    elif results_rsi['profit_pct'] > results_ma['profit_pct']:
        print("üèÜ Winner: RSI Strategy!")
    else:
        print("ü§ù It's a tie!")
    print()

    return results_ma, results_rsi

# ============================================================================
# MAIN EXAMPLES
# ============================================================================

print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                   ‚ïë
‚ïë        üêç PYTHON TRADING SIMULATOR - GOOGLE COLAB EDITION       ‚ïë
‚ïë                                                                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìö QUICK START GUIDE:

1Ô∏è‚É£  List available stocks:
    StockDataFetcher.list_stocks()

2Ô∏è‚É£  Run a quick backtest:
    quick_backtest('RELIANCE', 'MA', '1y', 100000)

3Ô∏è‚É£  Compare strategies:
    compare_strategies('TCS', '6mo', 100000)

4Ô∏è‚É£  Advanced usage:
    # Fetch data
    df = StockDataFetcher.get_data('INFY', '1y')

    # Apply strategy
    df = TradingStrategy.moving_average_crossover(df, 10, 50)

    # Run backtest
    backtester = Backtester(100000)
    results = backtester.run(df)

    # Plot
    plot_results(df, results, 'INFY')

üí° TIP: Start with a simple test:
    quick_backtest('RELIANCE')

üìä All strategies include:
   ‚úÖ DSA: Sliding Window for O(1) MA calculation
   ‚úÖ Real Nifty 50 stock data
   ‚úÖ Backtesting with realistic brokerage
   ‚úÖ Beautiful interactive charts
   ‚úÖ Performance metrics (return, win rate, drawdown)

Ready to test your first strategy? üöÄ
""")

# Test 1: See available stocks
StockDataFetcher.list_stocks()

# Quick backtest on Reliance for last 1 year
quick_backtest('RELIANCE', 'MA', '1y', 100000)

# Test TCS with RSI strategy
quick_backtest('TCS', 'RSI', '6mo', 150000)

# See which strategy works better
compare_strategies('INFY', '1y', 100000)